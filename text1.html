<!DOCTYPE html>
<html>
  <head>
    <style>
      .box {
        width: 100px;
        height: 100px;
        background-color: red;
        position: relative;
        animation: move 2s linear infinite;
      }

      @keyframes move {
        0% {
          left: 50%;
        }
        25% {
          left: 0;
        }
        50% {
          left: 50%;
        }
        75% {
          left: 100%;
        }
        100% {
          left: 50%;
        }
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
    <canvas id="myCanvas"></canvas>
    <script>
      // const canvas = document.getElementById("myCanvas");
      // const context = canvas.getContext("2d");

      // function drawCharacter() {
      //   const path = [
      //     { x: 50, y: 50 },
      //     { x: 100, y: 50 },
      //     { x: 100, y: 100 },
      //     { x: 50, y: 100 },
      //     { x: 50, y: 50 },
      //   ];

      //   let currentPointIndex = 0;

      //   function drawNextPoint() {
      //     const { x, y } = path[currentPointIndex];
      //     context.lineTo(x, y);
      //     context.stroke();

      //     currentPointIndex++;

      //     if (currentPointIndex < path.length) {
      //       setTimeout(drawNextPoint, 1000); // Add a delay of 1 second (1000 milliseconds)
      //     }
      //   }

      //   context.beginPath();
      //   context.moveTo(path[0].x, path[0].y);
      //   setTimeout(drawNextPoint, 1000); // Start the animation after 1 second (1000 milliseconds)
      // }

      // drawCharacter();
      // function shuffle(array) {
      //   let res = [],
      //     random;
      //   while (array.length > 0) {
      //     random = Math.floor(Math.random() * array.length);
      //     res.push(array[random]);
      //     array.splice(random, 1);
      //   }
      //   return res;
      // }

      // console.log(shuffle([1, 2, 3, 4, 5]));
      // function print(s) {
      //   console.log(s);
      //   var s = 2;
      //   function s() {}
      //   console.log(s);
      // }
      // print(1);
      // class Node {
      //   constructor(value) {
      //     this.value = value;
      //     this.next = null;
      //   }
      // }
      // function insertNode(head, value, position) {
      //   const newNode = new Node(value);
      //   if (position === 0) {
      //     newNode.next = head;
      //     return newNode;
      //   }
      //   let current = head;

      //   //                       2
      //   for (let i = 0; i < position - 1; i++) {
      //     if (current.next === null) {
      //       throw new Error("Invalid position");
      //     }
      //     current = current.next;
      //     //      =  2
      //   }
      //   //              3
      //   newNode.next = current.next;
      //   //  2
      //   current.next = newNode;
      //   return head;
      // }
      // 1. 创建一个表示节点的对象，包含一个值属性和一个指向下一个节点的next属性。
      // 2. 找到要插入节点的位置，即要插入节点的前一个节点。
      // 3. 将新节点的next属性指向前一个节点的next属性。
      // 4. 将前一个节点的next属性指向新节点。
      const obja = [
        { id: 1, parentId: null },
        { id: 2, parentId: 1 },
        { id: 3, parentId: 1 },
        { id: 4, parentId: 2 },
        { id: 5, parentId: 2 },
        { id: 6, parentId: 3 },
        { id: 7, parentId: 3 },
      ];
      // const { id, parentId } = obja;
      // console.log(obja[1]);
      // 根据父节点还原树function
      function restoreTree(nodes) {
        const tree = {};
        let head = null;
        nodes.forEach((node) => {
          const { id, parentId } = node;
          if (!tree[id]) {
            tree[id] = { id, children: [] };
          }
          if (parentId !== null) {
            if (!tree[parentId]) {
              tree[parentId] = { id: parentId, children: [] };
            }

            tree[parentId].children.push(tree[id]);
          }
          if (parentId === null) {
            head = id;
          }
        });
        const root = Object.values(tree).find((node) => node.id === head);
        return root;
      }
      const root = restoreTree(obja);
      console.log(root);
      //myInterval的性能更好。原因是，myInterval在每次定时器触发后都会设置一个新的定时器，以保证稳定的执行间隔。
      const myInterval = (fn, time) => {
        // 定义一个递归函数持续调用定时器
        const executor = (fn, time) => {
          setTimeout(() => {
            fn();
            executor(fn, time);
          }, time);
        };
        executor(fn, time);
      };

      myInterval(() => {
        console.log("111");
      }, 1000);

      //占用更多的内存空间，闭包里面创建闭包了
      // const myInterval2 = (fn, time) => {
      //   setTimeout(() => {
      //     fn();
      //     myInterval2(fn, time);
      //   }, time);
      // };
      // myInterval2(() => {
      //   console.log("222");
      // }, 1000);
    </script>
  </body>
</html>
